//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
//                                  (C) VESTA 2018                                      //
//        Het doel van het model is om beleidsinformatie te genereren met betrekking    //
//        tot de energievoorziening van de gebouwde omgeving.                           //
//                                                                                      //
//                         Planbureau voor de Leefomgeving                              //
//                                    JUNI 2018                                         //
//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
//     * In het geval van externe publicatie van onderzoeksresultaten waarbij gebruik   //
//       is gemaakt van de verstrekte gegevens dient de gebruiker deze resultaten aan   //
//       het PBL mede te delen middels de toezending van 2 exemplaren van de betref-    //
//       fende publicatie aan het hoofd van het team ROL van het PBL.                   //
//                                                                                      //
//     * In elke publicatie waarin de gegevens van het PBL in enige vorm zijn opgenomen,//
//       zal de gebruiker de vermelding opnemen: "Bron: Planbureau voor de Leefomgeving"//
//       Indien het een bewerking van de gegevens betreft, dient te worden opgenomen:   //
//       "Gebaseerd op Planbureau voor de Leefomgeving gegevens".                       //
//                                                                                      //
//     * Het PBL is onder geen enkele voorwaarde aansprakelijk tegenover gebruiker voor //
//       enige schade, mede begrepen winstderving, verlies van gegevens, schade         //
//       tengevolge van fouten of onjuistheden in gegevens, schade tengevolge van fouten//
//       of onvolkomenheden in de documentatie of andere incidentele of gevolgschade    //
//       welke voortvloeit uit of in verband staat met gebruik of het niet kunnen ge-   //
//       bruiken van gegevens.                                                          //
//                                                                                      //
//     * Het PBL staat niet in voor de juistheid van de resultaten die worden verkregen //
//       door combinatie van diverse, op zichzelf staande PBL-gegevens onderling,       //
//       of met die uit andere bronnen.                                                 //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

Template LtWarmtenetImpl
{
	// begin case parameters
	container BeginStatus;
	container AanbodKentallen;
	container EnergiePrijzen;
	parameter<units/yr_uint16> RunJaar;
	
	parameter<units/Celsius> T_ow;
	parameter<units/Celsius> T_sec;
	// end case parameters
	
	parameter<bool> CollectieveWP := (T_ow < T_sec);
		
	container KostenBaten           := BeginStatus/KostenBaten;
	container BebouwingsComponenten := KostenBaten/BebouwingsComponenten;

	unit<uint8>  WkoComponent       := Classifications/WkoComponent;
	unit<uint32> PlanRegio          := Invoer/SpecifiekeInstellingen/PlanRegio;
	unit<uint8>  Prijzen_elec       := Prijzen/Elektriciteit/Staffel;

	container constanten {
		parameter<Eur_kW> Ki_Doublet := Leercurves/Curve2 * 1133[Eur_kW]                                   , Descr = "bron zonder distributiekosten";
		parameter<Eur_m2> Ki_distr   := Leercurves/Curve2 * 6000[Eur_Woning] * 187[NrWoningen] / 15741[m2] , Descr = "Distributiekosten per proxy-m2 obv proxy-area voorbeeldproject in Zutphen, zie %projdir%/data/adres_Zutphen.ods";

		parameter<Float64> BijstookFactor := 2.0; // afgenomen warmte / geleverde warmte
		parameter<Float64> AandeelPrimairVermogen := 0.30; // primair beschikbare warmtecapaciteit / aangesloten warmtecapaciteit; rest wordt met CWP opgeplust.
		
		parameter<Float64> AandeelPrimairVolume   := 0.70; // primair geleverde warmte / afgenomen warmte (in GJ); rest wordt met CWP opgeplust.
		
		//Seasonal Performance Factors
		//REMOVE parameter<Ratio> SPF_coll: [3.5];
		parameter<Ratio> SPF_koude: [30]; // alleen wat pompkosten van water in de buurt via afgifte systeem naar buffer of terug
		
		parameter<Float64> SPF_ind_A_rv  := 1.0;
		parameter<Float64> SPF_ind_B_rv  := T_sec <= 35[Celsius] ? 4.2 : 1.0;
		parameter<Float64> SPF_ind_CE_rv := T_sec <= 35[Celsius] ? 3.2 :  T_sec <= 55[Celsius] ? 4.2 : 1.0;
		
		parameter<Float64> SPF_ind_ww  := T_sec <= 55[Celsius] ? 2.5 : 1.0;
		
		
		// Aandeel eigen opwekking
		parameter<Float64> AEO_ind_A_rv  := 0.0;
		parameter<Float64> AEO_ind_B_rv  := T_sec <= 35[Celsius] ? 0.3 : 0.0;
		parameter<Float64> AEO_ind_CE_rv := T_sec <= 35[Celsius] ? 0.6 : T_sec <= 55[Celsius] ? 0.3 : 0.0;
		
		parameter<Float64> AEO_ind_ww    := T_sec <= 35[Celsius] ? 0.5 : T_sec <= 55[Celsius] ? 0.2 : 0.0;

		parameter<EUR> Ki_booster := 2000[Eur]; //
		
		//ASW AanSluitWaarde
		parameter<float64> ASW_wc := 6[kW_Woning]; // collectief niet appt
		parameter<float64> ASW_kc := 2[kW_Woning];
		parameter<float64> ASW_wa := 5[kW_Woning]; // appartement
		parameter<float64> ASW_ka := 2[kW_Woning];
		parameter<float64> ASW_wu := 0.05[kW_m2]; // utiliteit
		parameter<float64> ASW_ku := 0.06[kW_m2];

		parameter<Eur_Woning> K_wvwc := Leercurves/Curve2 * 2000[Eur_Woning], Descr = "kosten afleverset (=warmtewisselaar+meter)        Notitie Issue 442";
		parameter<Eur_Woning> K_wvwa := Leercurves/Curve2 * 4000[Eur_Woning], Descr = "kosten inpandinge buizen + afleverset appartement Notitie Issue 442, issue 503.";
		
		parameter<EUR_KW> Ki_Uitkoppel:= 250 [EUR / KW];
		parameter<EUR_KW> Ki_WOS      := 680 [EUR / KW];
		parameter<EUR>    Ki_Buffer   := 100000[EUR];
	}
	
	container BestaandeWoningData :=
		WKOWoningData(
			BebouwingsComponenten/BestaandeWoning, 
			BeginStatus/KostenBaten/PlanRegioKaarten/BestaandeWoning/WarmtePrijs, 
			BebouwingsComponenten/BestaandeWoning/BebouwingsTypeDomein,
			BeginStatus/KostenBaten/KostenD/Wonen/bw
		);

	container NieuwbouwWoningData :=
		WKOWoningData(
			BebouwingsComponenten/NieuwbouwWoning, 
			BeginStatus/KostenBaten/PlanRegioKaarten/NieuwbouwWoning/WarmtePrijs, 
			BebouwingsComponenten/NieuwbouwWoning/BebouwingsTypeDomein,
			BeginStatus/KostenBaten/KostenD/Wonen/nw
		);

	container BestaandeUtilData :=
		WKOUtilData(
			BebouwingsComponenten/BestaandeUtil, 
			BeginStatus/KostenBaten/PlanRegioKaarten/BestaandeUtil/WarmtePrijs
		);
	
	container NieuwbouwUtilData :=
		WKOUtilData(
			BebouwingsComponenten/NieuwbouwUtil, 
			BeginStatus/KostenBaten/PlanRegioKaarten/NieuwbouwUtil/WarmtePrijs
		);
	
	parameter<string> geschiktExpr := 'BcData/energielabel/CurrValue <= Classifications/energielabel/V/LabelE';
	container CandidateSets := for_each_ne(WkoComponent/Name, 
		'WkoData('+WkoComponent/Name+'Data, '+Quote(WkoComponent/Name)+', T_sec, false, '+Quote(geschiktExpr)+')');
	
	parameter<EUR_GJ> BronWarmtePrijs :=  // @@@ we moeten hier iets aannemen om de bron-cluster opbrengsten ergens op te baseren.
			BebouwingsComponenten/NieuwbouwWoning/Warmtewet/WarmtePrijs * 0.80 
		+   BebouwingsComponenten/NieuwbouwUtil/Warmtewet/WarmtePrijs * 0.20;
	
	unit<uint32> BronSrc := Invoer/RuimtelijkeData/WarmteBronnen/LtWarmte/bron;
	unit<uint32> Bronnen := subset(BronSrc/cap_KW > 0.0) {
	
		attribute<rdc_meter> Point := BronSrc/Point[nr_OrgEntity];
		attribute<string>    Label := BronSrc/Label[nr_OrgEntity];
		
		attribute<.> Partitioning := id(.);
		attribute<bool> SelectAfweging := const(true, .);
//		attribute<EUR_Yr> AC_Netto := 250[EUR / KW] * P_Warmte * NCW/ow28/AnnualisationFactor;
		attribute<KW>     P_Warmte_primair := BronSrc/cap_KW[nr_OrgEntity];

//		attribute<EUR>     Ki_bron  := 250[EUR / KW] * cap_KW; // uitkoppelkosten bepalen obv WOS vraag 
		
		attribute<float64>   n           := const(1.0, .);
		attribute<float64>   MEAN_x      := PointCol(Point);
		attribute<float64>   MEAN_y      := PointRow(Point);
		attribute<float64>   SSD_xx      := const(0.0, .);
		attribute<float64>   SSD_xy      := const(0.0, .);
		attribute<float64>   SSD_yy      := const(0.0, .);
	}

	unit <uint32> UnitedCandidates := ='union_unit('+AsItemList('CandidateSets/'+WkoComponent/Name+'/AllowedObjects')+')'
	,	DialogType = "Map"
	,	DialogData = "Point"
	{
		attribute<string>    Label        := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/AllowedObjects/Label') + ')', DialogType = "LabelText";
		attribute<.>         Partitioning := id(.);
		attribute<rdc_meter> Point        := Point(MEAN_Y, MEAN_X, rdc_meter);

		attribute<Eur_yr>    Oj_verbruik  := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/Oj_verbruik[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<Eur_yr>    AC_Netto     := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/AC_Netto  [CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<GJ_Yr >    V_Warmte     := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/WkoDataComponent/V_Warmte[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<GJ_Yr >    V_Koude      := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/WkoDataComponent/V_Koude [CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<kW    >    P_Warmte     := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/WkoDataComponent/P_Warmte[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<kW    >    P_Koude      := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/WkoDataComponent/P_Koude [CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<KW>    P_Warmte_primair := P_Warmte * constanten/AandeelPrimairVermogen;

		attribute<float64>   n            := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/Gebied/n     [CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<float64>   MEAN_x       := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/Gebied/MEAN_x[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<float64>   MEAN_y       := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/Gebied/MEAN_y[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<float64>   SSD_xx       := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/Gebied/SSD_xx[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<float64>   SSD_xy       := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/Gebied/SSD_xy[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
		attribute<float64>   SSD_yy       := ='union_data(., ' + asItemList('CandidateSets/' + WkoComponent/Name + '/Gebied/SSD_yy[CandidateSets/' + WkoComponent/Name + '/AllowedObjects/nr_OrgEntity]') + ')';
	}

	parameter<uint32> NrBronIterations: [ 10 ]; // @@@
	unit<uint32> BronIteration := Range(uint32, 0, NrBronIterations) 
	{
		attribute<string> Name := 'I'+string(id(.));
		attribute<string> PrevBron := MakeDefined(Name[id(.)-1] + '/SelectedClusters', 'Bronnen');
		attribute<.> NrSelectedObjects          := ='union_data(BronIteration, '+AsItemList('#BronIterations/'+BronIteration/Name+'/Selected')+')';
		attribute<.> CumulNrPrevSelectedObjects := cumulate(NrSelectedObjects) - NrSelectedObjects;
	}

	container BronIterations := for_each_ne(BronIteration/Name, 'LtBronIter(' + BronIteration/PrevBron + ', Bronnen)');
	container LastBronIter :=  ='BronIterations/'+last(BronIteration/Name);
	container LastClusters := LastBronIter/SelectedClusters;
	
	unit<uint32> BronSelectie := ='union_unit('+asItemList('BronIterations/'+BronIteration/Name+'/Selected')+',LastClusters)', DialogType = "Map", DialogData = "Point"
	{
		attribute<rdc_meter> point := ='union_data(., '+asItemList('BronIterations/'+BronIteration/Name+'/Selected/point')+', LastClusters/Point)';
		attribute<string>    Label := ='union_data(., '+asItemList('BronIterations/'+BronIteration/Name+'/Selected/Label')+', LastClusters/Label)';
		
		attribute<kW>        P_Warmte_primair  := ='union_data(., '+AsItemList('BronIterations/'+BronIteration/Name+'/Selected/P_Warmte_primair')+', LastClusters/P_warmte_primair)';
		
		attribute<float64>   n      := ='union_data(., ' + asItemList('BronIterations/' + BronIteration/Name + '/Selected/n')+', LastClusters/n)';
		attribute<float64>   SSD_xx := ='union_data(., ' + asItemList('BronIterations/' + BronIteration/Name + '/Selected/SSD_xx')+', LastClusters/SSD_xx)';
		attribute<float64>   SSD_xy := ='union_data(., ' + asItemList('BronIterations/' + BronIteration/Name + '/Selected/SSD_xy')+', LastClusters/SSD_xy)';
		attribute<float64>   SSD_yy := ='union_data(., ' + asItemList('BronIterations/' + BronIteration/Name + '/Selected/SSD_yy')+', LastClusters/SSD_yy)';
		
		attribute<float64>   SqrtDetSSD  := MakeDefined(Sqrt(SSD_xx*SSD_yy-SSD_xy*SSD_xy), 0.0);
		attribute<m2>        AreaProxy   := (PI() * SqrtDetSSD / n)[m2];

		attribute<.>         Partitioning (UnitedCandidates) := Selected/BronSelectie_rel[invert(Selected/nr_OrgEntity)];
	}
	
	
	parameter<uint32> NrIterations: [ 25 ];
	unit<uint32> Iteration := Range(uint32, 0, NrIterations) 
	{
		attribute<string> Name := 'I'+string(id(.));
		attribute<string> PrevBest := MakeDefined(Name[id(.)-1] + '/SelectedClusters', 'UnitedCandidates');
	}
	
	// TODO: implementeer capacitated_connect, aangezien relevant cluster nu niet meer a priori gegeven is.
	attribute<BronSelectie> BronSelectie_rel(UnitedCandidates)  :=  connect(BronSelectie/point, UnitedCandidates/point);
	attribute<Float64>      BronSelectie_sqrdist(UnitedCandidates) :=  sqrdist(UnitedCandidates/point, BronSelectie/point[BronSelectie_rel]);
	attribute<Float64>      distance_threshold(BronSelectie) := nth_element_weighted(BronSelectie_sqrdist, BronSelectie/P_Warmte_primair, UnitedCandidates/P_Warmte_primair,  BronSelectie_rel);
	
	// afnemers nabij centrum van een geselecteerd bron-cluster
	unit<uint32> Selected := Subset(BronSelectie_sqrdist <= distance_threshold[BronSelectie_rel])
		,	DialogType = "Map", DialogData = "Point" 
	{
		attribute<rdc_meter> Point := UnitedCandidates/Point[nr_Orgentity];
		attribute<BronSelectie> BronSelectie_rel := ../BronSelectie_rel[nr_OrgEntity];
		attribute<EUR_Yr> Oj_Verbruik := UnitedCandidates/Oj_Verbruik[nr_OrgEntity];
		attribute<EUR_Yr> AC_Netto    := UnitedCandidates/AC_Netto[nr_OrgEntity];
		attribute<GJ_Yr> V_Warmte     := UnitedCandidates/V_Warmte[nr_OrgEntity];
		attribute<GJ_Yr> V_Koude      := UnitedCandidates/V_Koude [nr_OrgEntity];
		attribute<KW> P_Warmte_primair:= UnitedCandidates/P_Warmte_primair[nr_OrgEntity];
		attribute<KW> P_Warmte_secundair := UnitedCandidates/P_Warmte[nr_OrgEntity];
		attribute<KW> P_Koude         := UnitedCandidates/P_Koude [nr_OrgEntity];
		attribute<float64> n      := UnitedCandidates/n     [nr_OrgEntity] + UnitedCandidates/n[nr_OrgEntity];
		attribute<float64> SSD_xx := UnitedCandidates/SSD_xx[nr_OrgEntity] + abs(PointCol(BronSelectie/point[BronSelectie_rel]) - PointCol(UnitedCandidates/point[nr_OrgEntity]));
		attribute<float64> SSD_yy := UnitedCandidates/SSD_yy[nr_OrgEntity] + abs(PointRow(BronSelectie/point[BronSelectie_rel]) - PointRow(UnitedCandidates/point[nr_OrgEntity]));
		attribute<float64> SSD_xy := UnitedCandidates/SSD_yy[nr_OrgEntity] 
			+ sqrt(
				 (PointRow(BronSelectie/point[BronSelectie_rel]) - PointRow(UnitedCandidates/point[nr_OrgEntity])) 
				*(PointCol(BronSelectie/point[BronSelectie_rel]) - PointCol(UnitedCandidates/point[nr_OrgEntity])));
	} // TODO: check that sign of covar matches the sign of the initial cluster covar, or should interference with source network be a good thing?
	
	container Gebied {
		attribute<float64>   n     (BronSelectie) := BronSelectie/n      + sum(Selected/n,      Selected/BronSelectie_rel);
		attribute<float64>   SSD_xx(BronSelectie) := BronSelectie/SSD_xx + sum(Selected/SSD_xx, Selected/BronSelectie_rel);
		attribute<float64>   SSD_yy(BronSelectie) := BronSelectie/SSD_yy + sum(Selected/SSD_yy, Selected/BronSelectie_rel);
		attribute<float64>   SSD_xy(BronSelectie) := BronSelectie/SSD_xy + sum(Selected/SSD_xy, Selected/BronSelectie_rel);
		
		attribute<float64>   SqrtDetSSD(BronSelectie)  := MakeDefined(Sqrt(SSD_xx*SSD_yy-SSD_xy*SSD_xy), 0.0);
		attribute<m2>        AreaProxy (BronSelectie)  := (PI() * SqrtDetSSD / n)[m2];
		
		attribute<GJ_Yr>     V_Warmte          (BronSelectie)  := sum(Selected/V_Warmte,           Selected/BronSelectie_rel);
		attribute<KW>        P_Warmte_primair  (BronSelectie)  := sum(Selected/P_Warmte_primair,   Selected/BronSelectie_rel);
		attribute<KW>        P_Warmte_secundair(BronSelectie)  := sum(Selected/P_Warmte_secundair, Selected/BronSelectie_rel);

		attribute<Eur>       Ki_A        (BronSelectie):= (constanten/Ki_Uitkoppel + constanten/Ki_WOS) * P_Warmte_secundair + constanten/Ki_Buffer;
		attribute<Eur_yr>    AC_Netto    (BronSelectie) := sum(Selected/AC_Netto, Selected/BronSelectie_rel);
		attribute<Eur_yr>    Oj_Verbruik (BronSelectie) := sum(Selected/Oj_Verbruik, Selected/BronSelectie_rel);
		attribute<Eur>       Ki_B        (BronSelectie)   := AreaProxy * constanten/Ki_distr; // omvat area voor broncluster, TODO: broncluster en  afname cluster splitsen.
		attribute<Eur_yr>    Kj_admin    (BronSelectie)   := (Ki_A + Ki_B) * 0.025[_Yr];
		attribute<Eur_yr>    Kj_onderhoud(BronSelectie)   := 
			  constanten/Ki_Uitkoppel * P_Warmte_primair  * 0.05[_Yr]
			+ constanten/Ki_WOS       * P_Warmte_secundair* (CollectieveWP ? 0.035[_Yr] : 0.025[_Yr])
			+ constanten/Ki_Buffer    * 0.05[_Yr];
		
		attribute<GJ_Yr>     V_Elek(BronSelectie) := (1.0 - constanten/AandeelPrimairVolume) * V_Warmte;
		attribute<classifications/gebruiksgrootteklasse> gebruiksgrootteklasse_rel (BronSelectie) := classify(V_Elek, Prijzen_elec/ClassBreak);
		
		attribute<Eur_yr>    Kj_hulpCWP (BronSelectie)    := V_Elek * Prijzen_elec/KGJ_eindgebruik_excl[gebruiksgrootteklasse_rel];
		attribute<Eur_yr>    Km_hulpCWP (BronSelectie)    := V_Elek * Prijzen_elec/KGJ_maatschappelijk [gebruiksgrootteklasse_rel];
		attribute<Eur_yr>    Kj_total   (BronSelectie)    := Ki_B * NCW/ow28/AnnualisationFactor + Kj_admin + Kj_onderhoud + Kj_hulpCWP;
		attribute<Eur_yr>    Km_total   (BronSelectie)    := Ki_B * NCW/ow28/AnnualisationFactor + Kj_admin + Kj_onderhoud + Km_hulpCWP;
		attribute<bool>      Afweging   (BronSelectie)    := Kj_total < AC_Netto; 
	}
	unit<uint32> RendabelCluster := subset(gebied/Afweging) {
		attribute<Eur_yr> Oj_Verbruik := Gebied/Oj_Verbruik[nr_OrgEntity];
	}
	
	attribute<uint32> NrAllowedObjects          (WkoComponent) := ='union_data(WkoComponent, '+AsItemList('#CandidateSets/'+WkoComponent/Name+'/AllowedObjects')+')';
	attribute<uint32> NrAllObjects              (WkoComponent) := ='union_data(WkoComponent, '+AsItemList('#CandidateSets/'+WkoComponent/Name+'/BebouwingsObject')+')';
	attribute<uint32> CumulNrPrevAllowedObjects (WkoComponent) := cumulate(NrAllowedObjects)-NrAllowedObjects;
	attribute<uint32> CumulNrPrevAllObjects     (WkoComponent) := cumulate(NrAllObjects)-NrAllObjects;

	container ObjectResults :=
		for_each_ne(WkoComponent/Name, 
			'WkoResults('
				'UnitedCandidates, BronSelectie, CandidateSets/'+WkoComponent/Name+','
				'CumulNrPrevAllowedObjects['+string(id(WkoComponent))+'[WkoComponent]],'
				'CumulNrPrevAllObjects['+string(id(WkoComponent))+'[WkoComponent]]'
			')'
		);

	unit<uint32> AllObjects := ='union_unit('+AsItemList('ObjectResults/'+WkoComponent/Name+'/BebouwingsObject')+')'
	{
		attribute<string>   Label       := ='union_data(., ' + asItemList('BebouwingsComponenten/' + WkoComponent/Name + '/BebouwingsObject/Label') + ')', DialogType = "LabelText";
		attribute<Selected> Cluster_rel := ='union_data(., ' + AsItemList('ObjectResults/'+WkoComponent/Name+'/Cluster_rel')+')';
		attribute<Eur>      Ki_C        := ='union_data(., ' + AsItemList('ObjectResults/'+WkoComponent/Name+'/WkoData/Ki_C')+')';
		attribute<Eur>      Ki_A_Part   := scalesum(max_elem(Ki_C, 1[Eur]), Cluster_rel, Gebied/Ki_A);
		attribute<Eur>      Ki_B_Part   := scalesum(max_elem(Ki_C, 1[Eur]), Cluster_rel, Gebied/Ki_B);
	}

	container Results := BeginStatus
	{
		container Bebouwing :=
			for_each_ne(Classifications/BebouwingsComponent/Name
				, Classifications/BebouwingsComponent/KanWKO 
					? 'ObjectResults/'+Classifications/BebouwingsComponent/Name+'/Result' 
					: 'BeginStatus/Bebouwing/'+Classifications/BebouwingsComponent/Name
			);
			
		container AanbodOpties : = BeginStatus/AanbodOpties
		{
			unit<uint32> WkoCluster := Selected;
		}

		container Stock := BeginStatus/Stock;
		container Flow  := BeginStatus/Flow;

		container PrevLtWarmtenet := =(CollectieveWP ? "BeginStatus/LtWarmtenetMetCollectieveWP" : "BeginStatus/LtWarmtenetMetIndividueleWP");
		container LtWarmtenet
		{
			// accumulated capital
			container Oi_Aansl := for_each_nedv(WkoComponent/Name, replace('BeginStatus/Wko/Oi_Aansl/@W@ + ObjectResults/@W@/PR/Oi_Aansl', '@W@', WkoComponent/Name), PlanRegio, Eur);

			// recalculated stock
			attribute<Eur>    Ki_id       (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Ki_id')+')';
			attribute<Eur>    Ki_ge_pm    (PlanRegio) := ObjectResults/BestaandeWoning/PR/Ki_ge_pm;
			attribute<Eur>    Ki_ge_ov    (PlanRegio) := ObjectResults/BestaandeWoning/PR/Ki_ge_ov;
			
			// recalculated Flow
			container Oj_Verbruik := for_each_nedv(WkoComponent/Name, replace('ObjectResults/@W@/PR/Oj_Verbruik', '@W@', WkoComponent/Name), PlanRegio, Eur_yr);
			container Om_comfort  := for_each_nedv(WkoComponent/Name, replace('ObjectResults/@W@/PR/Om_comfort' , '@W@', WkoComponent/Name), PlanRegio, Eur_yr);

			attribute<Eur_yr> Kj_wd_pr    (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Kj_wd_pr')+')';
			attribute<Eur_yr> Km_ow_e     (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Km_ow_e')+')';
			attribute<Eur_yr> Kj_ow_e     (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Kj_ow_e')+')';
			attribute<Eur_yr> Kj_ow_o     (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Kj_ow_o')+')';
//			attribute<Eur_yr> Oj_verbruik (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Oj_verbruik')+')';
//			attribute<Eur_yr> Om_comfort  (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Om_comfort')+')';
			attribute<Eur_yr> KEH_ow_e    (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/KEH_ow_e')+')';
			attribute<Eur_yr> Kj_ge       (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/Kj_ge')+')';

			// accumulated stock
			attribute<Eur>    Ki_ow       (PlanRegio) := ='PrevLtWarmtenet/Ki_ow + add('+AsItemList('ObjectResults/'+WkoComponent/Name+'/PR/Ki_ow')+')';
			attribute<Eur>    Ki_wd       (PlanRegio) := ='PrevLtWarmtenet/Ki_wd + add('+AsItemList('ObjectResults/'+WkoComponent/Name+'/PR/Ki_wd')+')';
//			attribute<Eur_yr> Kj_ge_hv    (PlanRegio) := BeginStatus/Wko/Kj_ge_hv + ObjectResults/Woning/PR/Kj_ge_hv;
//			attribute<Eur>    Oi_Aansl    (PlanRegio) := ='add('+AsItemList('ObjectResults/'+WkoComponent/Name+'/PR/Oi_Aansl')+')';

			attribute<Eur_yr> Kj_ge_Bruto (PlanRegio) :=                     Ki_ge * NCW/bw28/AnnualisationFactor;
			attribute<Eur_yr> Kj_id_Bruto (PlanRegio) :=                     Ki_id * NCW/id28/AnnualisationFactor;
//			attribute<Eur_yr> Kj_wd_Bruto (PlanRegio) := Kj_wd_pr          + Ki_wd * NCW/wd28/AnnualisationFactor;
//			attribute<Eur_yr> Kj_ow_Bruto (PlanRegio) := Kj_ow_o + Kj_ow_e + Ki_ow * NCW/ow28/AnnualisationFactor;

			attribute<Eur>    Ki_ge       (PlanRegio) := Ki_ge_pm + Ki_ge_ov;
			attribute<Eur>    Ki_Totaal   (PlanRegio) := Ki_id + Ki_ge ; // +Ki_ow + Ki_wd

			attribute<Eur_yr> Km_Totaal   (PlanRegio) := Km_ow_e + Kj_ow_o;

//			attribute<Eur>    Si_ow       (PlanRegio) := Ki_ow * SpecifiekeInstellingen/Beleid/EIA/wko;
//			attribute<Eur>    Si_wd       (PlanRegio) := Ki_wd * SpecifiekeInstellingen/Beleid/EIA/wd;
			attribute<Eur>    Si_id       (PlanRegio) := Ki_id * SpecifiekeInstellingen/Beleid/EIA/id;
			attribute<Eur>    Si_ge       (PlanRegio) := Ki_ge_pm * SpecifiekeInstellingen/Beleid/EIA/E_bw/Rs_ProjectManagement + Ki_ge_ov * SpecifiekeInstellingen/Beleid/EIA/E_bw/Rs_OngeriefsVergoeding;
//			attribute<Eur>    Si_T        (PlanRegio) := Si_ow + Si_wd + Si_id + Si_ge;

//			attribute<Eur>    Ki_ow_Netto (PlanRegio) := Ki_ow - Si_ow;
//			attribute<Eur>    Ki_wd_Netto (PlanRegio) := Ki_wd - Si_wd;
			attribute<Eur>    Ki_id_Netto (PlanRegio) := Ki_id - Si_id;
			attribute<Eur>    Ki_ge_Netto (PlanRegio) := Ki_ge - Si_ge;

//			attribute<Eur_yr> Sj          (PlanRegio) := Si_ow * NCW/ow28/AnnualisationFactor + Si_wd * NCW/wd28/AnnualisationFactor + Si_id * NCW/id28/AnnualisationFactor + Si_ge * NCW/bw28/AnnualisationFactor;
//			attribute<Eur_yr> Sm          (PlanRegio) := Si_T * NCW/mr28/AnnualisationFactor;

			attribute<Eur_yr> SDE         (PlanRegio) := GJw_Totaal * SpecifiekeInstellingen/Beleid/EEA/SDE_WKO;
//			attribute<Eur_yr> Se_ow       (PlanRegio) := Ki_ow_Netto * NCW/ow28/AnnualisationFactor * SpecifiekeInstellingen/Beleid/EEA/wko + SDE;
//			attribute<Eur_yr> Se_wd       (PlanRegio) := Ki_wd_Netto * NCW/wd28/AnnualisationFactor * SpecifiekeInstellingen/Beleid/EEA/wd;
			attribute<Eur_yr> Se_id       (PlanRegio) := Ki_id_Netto * NCW/id28/AnnualisationFactor * SpecifiekeInstellingen/Beleid/EEA/id;
			attribute<Eur_yr> Se_ge       (PlanRegio) := Ki_ge_Netto * NCW/bw28/AnnualisationFactor * SpecifiekeInstellingen/Beleid/EEA/ge;
//			attribute<Eur_yr> Se          (PlanRegio) := Sj + Se_ow + Se_wd + Se_id + Se_ge;
//			attribute<Eur_yr> Sme         (PlanRegio) := Sm + Se_ow + Se_wd + Se_id + Se_ge;

			attribute<Eur_yr> Kj_ge_netto (PlanRegio) := Ki_ge_Netto * NCW/bw28/AnnualisationFactor - Se_ge;
			attribute<Eur_yr> Kj_id_netto (PlanRegio) := Ki_id_Netto * NCW/id28/AnnualisationFactor - Se_id;
//			attribute<Eur_yr> Kj_wd_netto (PlanRegio) := Kj_wd_pr + Ki_wd_Netto * NCW/wd28/AnnualisationFactor - Se_wd;
//			attribute<Eur_yr> Kj_ow_netto (PlanRegio) := Kj_ow_o + Kj_ow_e + Ki_ow_Netto * NCW/ow28/AnnualisationFactor - Se_ow;
//			attribute<Eur_yr> Kj_netto    (PlanRegio) := Kj_ge_netto + Kj_id_netto + Kj_wd_netto + Kj_ow_netto;
			attribute<Eur   > Oi_AanslT   (PlanRegio) := ='add('+AsItemList('Oi_Aansl/'+WkoComponent/Name)+')';
			attribute<Eur_yr> Oj_VerbrT   (PlanRegio) := ='add('+AsItemList('Oj_Verbruik/'+WkoComponent/Name)+')';
			attribute<Eur_yr> Oj_totaal   (PlanRegio) := Oj_VerbrT + Oi_AanslT * (NCW/id28/StartDiscountFactor * NCW/id28/AnnualisationFactor);

			// CO2: geen bijstook nodig, want verwarming per eWP met LTAS; wel CO2 voor elektriciteit voor collectieve warmtepomp
			attribute<Eur_yr> KCO2_ow_e   (PlanRegio) := ='add('+AsItemList('ObjectResults/'+WkoComponent/Name+'/PR/KCO2_ow_e')+')';
			attribute<KG_yr>  CO2         (PlanRegio) := GJe_Totaal * prijzen/Elektriciteit/CO2_GJ;

			attribute<GJ_yr>  GJe_Totaal  (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/GJe')+')';
			attribute<GJ_yr>  GJw_Totaal  (PlanRegio) := ='add('+AsItemList('ObjectResults/' + WkoComponent/Name + '/PR/GJw')+')';
		}
		container KostenBaten := CalculationSchemes/KostenBaten(Bebouwing, Energieprijzen, RunJaar);
	}
}
