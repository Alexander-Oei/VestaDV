//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
//                                  (C) VESTA 2018                                      //
//        Het doel van het model is om beleidsinformatie te genereren met betrekking    //
//        tot de energievoorziening van de gebouwde omgeving.                           //
//                                                                                      //
//                         Planbureau voor de Leefomgeving                              //
//                                    JUNI 2018                                         //
//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
//     * In het geval van externe publicatie van onderzoeksresultaten waarbij gebruik   //
//       is gemaakt van de verstrekte gegevens dient de gebruiker deze resultaten aan   //
//       het PBL mede te delen middels de toezending van 2 exemplaren van de betref-    //
//       fende publicatie aan het hoofd van het team ROL van het PBL.                   //
//                                                                                      //
//     * In elke publicatie waarin de gegevens van het PBL in enige vorm zijn opgenomen,//
//       zal de gebruiker de vermelding opnemen: "Bron: Planbureau voor de Leefomgeving"//
//       Indien het een bewerking van de gegevens betreft, dient te worden opgenomen:   //
//       "Gebaseerd op Planbureau voor de Leefomgeving gegevens".                       //
//                                                                                      //
//     * Het PBL is onder geen enkele voorwaarde aansprakelijk tegenover gebruiker voor //
//       enige schade, mede begrepen winstderving, verlies van gegevens, schade         //
//       tengevolge van fouten of onjuistheden in gegevens, schade tengevolge van fouten//
//       of onvolkomenheden in de documentatie of andere incidentele of gevolgschade    //
//       welke voortvloeit uit of in verband staat met gebruik of het niet kunnen ge-   //
//       bruiken van gegevens.                                                          //
//                                                                                      //
//     * Het PBL staat niet in voor de juistheid van de resultaten die worden verkregen //
//       door combinatie van diverse, op zichzelf staande PBL-gegevens onderling,       //
//       of met die uit andere bronnen.                                                 //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
//       Deze DMS-file wordt aangeroepen door stam.dms                                  //
//       In deze configuratiefile wordt de Geography gedefinieerd:                      //
//       - geografische basis eenheden en grid domeinen voor brondata                   //
//       - regioindelingen (polygonen)                                                  //
//                                                                                      //
// ///////////////////////////////////////////////////////////////////////////////////////

container Geography: Using = "Units"
{
	unit<dpoint> rdc_meter_base : DialogData = "ngr_layer";
	unit<dpoint> rdc_meter      := range(rdc_meter_base, point(300000.0, 0.0), point(625000.0, 280000.0));
	unit<fpoint> rdc_meter_f32  := gridset(rdc_meter, point(1.0, 1.0), point(0.0, 0.0), fpoint);
	unit<ipoint> rdc_mm         := gridset(rdc_meter, point(0.001, 0.001), point(0.0,0.0), ipoint);

	#include <ngr_layer.dms>

	container rdc_grids
	{
		unit<wpoint> m100 :=
			range(
				gridset(rdc_meter, point( - 100.0, 100.0),  point(625000.0, 10000.0), wpoint),
				point(0w, 0w),
				point(3250w, 2700w)
			)
			,	Descr = "rdCoords/100m van NW naar SE (2700 cols)"
		{
			attribute<rdc_meter>           Point           := id(.)[rdc_meter] + Point(-50.0, 50.0, rdc_meter);
			attribute<RegioIndelingen/PC4> PC4_rel_org     := point_in_polygon(Point, RegioIndelingen/PC4/Geometry);
			attribute<bool>                PC4_org_defined := IsDefined(PC4_rel_org);
	
			unit<uint32> NearPC4:= Subset(potential(float32(PC4_org_defined), DistMatrices/impl/pot1000m/potrange/Cilindrical) >= 0.000001f && !PC4_org_defined);
	
			container Connect := connect_info( RegioIndelingen/PC4/Geometry, Point[NearPC4/nr_OrgEntity]);
	
			attribute<RegioIndelingen/PC4>      PC4_rel      := MakeDefined(PC4_rel_org, Connect/ArcID[invert(NearPC4/nr_OrgEntity)]), FreeData = "False";
			attribute<RegioIndelingen/grid500m> grid500m_rel := RegioIndelingen/grid500m/BaseGrid[ ID(.)[m500] ];
			attribute<RegioIndelingen/grid1km>  grid1km_rel  := RegioIndelingen/grid1km/BaseGrid[ ID(.)[km1] ];
			attribute<RegioIndelingen/grid2km>  grid2km_rel  := RegioIndelingen/grid2km/BaseGrid[ ID(.)[km2 ] ];
		}
	
		unit<wpoint> m500 := gridset(rdc_grids/m100, point( 5w, 5w, m100), point(0w,0w, m100), wpoint)
		{
			attribute<RegioIndelingen/PC4>   PC4_rel   := poly2grid(RegioIndelingen/PC4/Geometry, .);
			attribute<RegioIndelingen/buurt> buurt_rel := poly2grid(RegioIndelingen/buurt/poly,   .);
			attribute<rdc_meter>             Point     := id(.)[rdc_meter] + Point(-250.0, 250.0, rdc_meter);
			attribute<Bool>                  IsNL      := IsDefined(buurt_rel);
		}
		
		unit<wpoint> km1 := gridset(rdc_grids/m100, point(10w, 10w, m100), point(0w,0w, m100), wpoint)
		{
			attribute<RegioIndelingen/PC4>   PC4_rel   := poly2grid(RegioIndelingen/PC4/Geometry, .);
			attribute<RegioIndelingen/buurt> buurt_rel := poly2grid(RegioIndelingen/buurt/poly,   .);
			attribute<rdc_meter>             Point     := id(.)[rdc_meter] + Point(-500.0, 500.0, rdc_meter);
			attribute<Bool>                  IsNL      := IsDefined(buurt_rel);
		}
		
		unit<wpoint> km2 := gridset(rdc_grids/m100, point(20w, 20w, m100), point(0w, 0w, m100), wpoint)
		{
			attribute<RegioIndelingen/PC4>   PC4_rel   := poly2grid(RegioIndelingen/PC4/Geometry, .);
			attribute<RegioIndelingen/buurt> buurt_rel := poly2grid(RegioIndelingen/buurt/poly,   .);
			attribute<rdc_meter>             Point     := id(.)[rdc_meter] + Point(-1000.0, 1000.0, rdc_meter);
			attribute<Bool>                  IsNL      := IsDefined(buurt_rel);
		}
	}
	container RegioIndelingen
	{
		unit<uint32> NL: nrofrows = 1
		{
			attribute<String> Name      := const('NL', .);
			parameter<String> RegioNaam := 'NL';
		}

		unit<uint32> Provincie := unique(buurt/PROVNR)
		{
			attribute<string> label := rjoin(values, buurt/PROVNR, buurt/PROVNM);
			
			attribute<String> Name      := replace_value(Replace(Label, '-', ''), '', 'Elders');
			parameter<String> RegioNaam := 'Provincie';
		}

		unit<uint32> Gemeente := unique(buurt/GEMNR2017)
		{
			attribute<string> name      := 'G'+string(Values);
			attribute<string> label     := rjoin(values, buurt/GEMNR2017, buurt/GEMNM2017);
			parameter<String> RegioNaam := 'Gemeente';
		}

		#include<buurt.dms>

		container CBS {
			unit<uint32> kwb2013:
				StorageName     = "%SourceDataProjDir%/CBS/kwb-2013.csv",
				StorageType     = "gdal.vect",
				StorageReadOnly = "True"
			{
			}
			unit<uint32> kwb2014:
				StorageName     = "%SourceDataProjDir%/CBS/kwb-2014.csv",
				StorageType     = "gdal.vect",
				StorageReadOnly = "True"
			{
			}
			unit<uint32> kwb2015:
				StorageName     = "%SourceDataProjDir%/CBS/kwb-2015.csv",
				StorageType     = "gdal.vect",
				StorageReadOnly = "True"
			{
			}
		}

		unit<uint32> PC4_Gemeente_NL:
			StorageName     = "%SourceDataProjDir%/hulpbestanden/gemeenten_2011/GemeenteGrenzen_2011_org_KAD_aggregatie_230812_union_IRIS_PC04_2011_strip.shp",
			StorageType     = "gdal.vect",
			DialogData      = "Geometry",
			DialogType      = "Map",
			StorageReadOnly = "True",
			SyncMode        = "Attr"
		{
			attribute<rdc_meter> Geometry(poly);

			attribute<uint16> PC4;
			attribute<String> PC4Str    := string(PC4);
			attribute<../PC4> PC4_rel_1 := rlookup(PC4, ../PC4/code);
			attribute<../PC4> PC4_rel   := max(Shape_area, PC4_rel_1)[PC4_rel_1] == Shape_area ? PC4_rel_1 : value(0 / 0, ../PC4);
		}

		unit<uint32> PC4Rap := Unique(PC4_Gemeente_NL/PC4Str)
		{
			attribute<uint16> PC4Nr     := rjoin(Values, PC4_Gemeente_NL/PC4Str, PC4_Gemeente_NL/PC4);
			attribute<String> Name      := 'PC4_'+String(PC4Nr);
			attribute<String> Label     := Values;
			parameter<String> RegioNaam := 'PC4';
		}

		unit<uint32> PC4:
			StorageName     = "%SourceDataProjDir%/hulpbestanden/pc04_vlakken_2009/Postcode4Gebieden_2009_IRIS.shp",
			StorageType     = "gdal.vect",
			DialogType      = "Map",
			DialogData      = "Geometry",
			SyncMode        = "None",
			StorageReadOnly = "True"
		{
			attribute<rdc_meter> Geometry(polygon): label = "Postcode 4 gebieden Nederland 2009"
			{
				parameter<uint32> BrushColor := rgb(255,255,255), DialogType = "BrushColor";
				parameter<uint32> PenColor   := rgb(167,167,167), DialogType = "PenColor";
				parameter<int16>  PenWidth   := 1s              , DialogType = "PenWidth";
			}

			attribute<uint16>          POSTCODE4;
			attribute<rdc_meter>       point                 := Centroid_or_mid(Geometry);
			attribute<m2>              Area                  := Area(Geometry, m2);
			attribute<km2>             AreaInKm2             := Area / value(1000000, m2 / km2);
			attribute<uint16>          code                  := POSTCODE4;
			attribute<String>          Label                 := String(code), DialogType = "LabelText";

			attribute<PC4_Gemeente_NL> PC4_Gemeente_NL_rel   := invert(PC4_Gemeente_NL/PC4_rel);
			attribute<uint32>          PC4_Gemeente_NL_count := pcount(PC4_Gemeente_NL/PC4_rel);
			attribute<NL>              NL_rel                := const(0[NL],.);
			attribute<Gemeente>        Gemeente_rel          := rlookup(PC4_Gemeente_NL/GEMNR[PC4_Gemeente_NL_rel], Gemeente/Values);
			attribute<PC4_Gemeente_NL> PC4_rel               := rlookup(PC4_Gemeente_NL/PC4Str[PC4_Gemeente_NL_rel], PC4Rap/Values);
			attribute<Provincie>       Provincie_rel         := MakeDefined(rlookup(PC4_Gemeente_NL/PRVNR[PC4_Gemeente_NL_rel], Provincie/Values), 0[Provincie]);

			attribute<yr_uint16>       BioWKK_Start          := const(2020[yr_uint16], .); // jaar waar vanaf BMC in een planregio is toegestaan. gebruik 9999 of ieder getal hoger dan laatste zichtjaar om geheel te verbieden.
		}

		unit<uint32> PC6:
			StorageName     = "%SourceDataProjDir%/hulpbestanden/pc06_vlakken_simplify/PC6gebieden_2006_KAD_simplify.dbf",
			DialogData      = "poly",
			DialogType      = "Map",
			StorageReadOnly = "True"
		{
			attribute<rdc_meter> poly(polygon):
				label           = "Postcode 6 gebieden Nederland 2006 obv percelen",
				StorageName     = "%SourceDataProjDir%/hulpbestanden/pc06_vlakken_simplify/PC6gebieden_2006_KAD_simplify.shp",
				StorageReadOnly = "True";
			attribute<String> PostCode;
			attribute<String> code := PostCode;
			attribute<uint32> len  := strlen(code);
			
			attribute<String>  code4str := substr(PostCode,0,4);
			attribute<uint16>  code4    := uint16(code4str);
			attribute<PC4>     PC4_rel  := rlookup(code4, PC4/code);
		}

		unit<uint32> grid2km: Expr = "Subset(const(true,rdc_grids/km2))", DialogType = "Map", DialogData = "BaseGrid" // guarantee that all objects are in a plan-region
		{
			attribute<.>         BaseGrid(rdc_grids/km2): Expr = "invert(nr_OrgEntity)";
			
			attribute<rdc_meter> Point:    Expr  = "rdc_grids/km2/point[nr_OrgEntity]";
			
			attribute<km2>       AreaInKm2: Expr = "const(4.0[km2], .)";
			
			// Report Regio relations

			attribute<NL>        NL_rel       := const(0[NL],.);
			attribute<Gemeente>  Gemeente_rel := RegioIndelingen/buurt/Gemeente_rel [rdc_grids/km2/buurt_rel[nr_OrgEntity]];
			attribute<Provincie> Provincie_rel:= RegioIndelingen/buurt/Provincie_rel[rdc_grids/km2/buurt_rel[nr_OrgEntity]];
			
			attribute<yr_uint16> BioWKK_Start: Expr = "const(2020[yr_uint16], .)"; // jaar waar vanaf BMC in een planregio is toegestaan. gebruik 9999 of ieder getal hoger dan laatste zichtjaar om geheel te verbieden.
		}

		unit<uint32> grid1km := Subset(const(true,rdc_grids/km1)), DialogType = "Map", DialogData = "BaseGrid" // guarantee that all objects are in a plan-region
		{
			attribute<.>    BaseGrid(rdc_grids/km1) := invert(nr_OrgEntity);
			
			attribute<rdc_meter> Point: Expr  = "rdc_grids/km1/point[nr_OrgEntity]";
			
			attribute<km2>       AreaInKm2: Expr = "const(1.0[km2], .)";
			
			// Report Regio relations

			attribute<NL>        NL_rel       := const(0[NL],.);
			attribute<Gemeente>  Gemeente_rel := RegioIndelingen/buurt/Gemeente_rel [rdc_grids/km1/buurt_rel[nr_OrgEntity]];
			attribute<Provincie> Provincie_rel:= RegioIndelingen/buurt/Provincie_rel[rdc_grids/km1/buurt_rel[nr_OrgEntity]];
			
			attribute<yr_uint16> BioWKK_Start: Expr = "const(2020[yr_uint16], .)"; // jaar waar vanaf BMC in een planregio is toegestaan. gebruik 9999 of ieder getal hoger dan laatste zichtjaar om geheel te verbieden.
		}

		unit<uint32> grid500m := Subset(const(true, rdc_grids/m500)), DialogType = "Map", DialogData = "BaseGrid" // guarantee that all objects are in a plan-region
		{
			attribute<.>         BaseGrid (rdc_grids/m500) := invert(nr_OrgEntity);

			attribute<rdc_meter> Point     := rdc_grids/m500/point[nr_OrgEntity];
			attribute<km2>       AreaInKm2 := const(0.25[km2], .);

			// Report Regio relations
			attribute<NL>        NL_rel       := const(0[NL],.);
			attribute<Gemeente>  Gemeente_rel := RegioIndelingen/Buurt/Gemeente_rel [rdc_grids/m500/Buurt_rel[nr_OrgEntity]];
			attribute<Provincie> Provincie_rel:= RegioIndelingen/buurt/Provincie_rel[rdc_grids/m500/Buurt_rel[nr_OrgEntity]];
			
			attribute<yr_uint16> BioWKK_Start := const(2020[yr_uint16], .); // jaar waar vanaf BMC in een planregio is toegestaan. gebruik 9999 of ieder getal hoger dan laatste zichtjaar om geheel te verbieden.
		}
	}

	// Distmatrices are used for potential analyses
	container DistMatrices
	{
		unit<uint32> Dist2Range;

		template potrange
		{
			// ===================== Begin Case Parameters
			parameter<m> gridsize;
			parameter<m> radius_max;
			// ===================== End Case Parameters
	
			parameter<Float64> radius   := radius_max / gridsize;
			unit<spoint>       tmpRange := range(spoint, point(-int16(radius), -int16(radius)), point(int16(radius) + 1s, int16(radius) + 1s));
			unit<spoint>       potRange := tmpRange
			{
				attribute<Dist2Range> distMatr      := dist2(point(0s, 0s, tmpRange), Dist2Range);
				attribute<Float64>    DecayedWeight := iif(distMatr <= uint32(radius * radius), 1.0 / (Float64(distMatr) + 0.08), 0.0);

				attribute<float32>    Reciprocal    := float32(scalesum(Sqrt(DecayedWeight), 1.0 ));
				attribute<float32>    Cilindrical   := float32(scalesum(float64(distMatr <= uint32(radius * radius)), 1.0 ));
			}
		}

		Container impl
		{
			container pot1000m  := potrange(100[m],  1000[m]);
			container pot5000m  := potrange(100[m],  5000[m]);
			container pot10000m := potrange(100[m], 10000[m]);
		}
		unit<spoint> pot1000mRange := impl/pot1000m/potrange;
		unit<spoint> pot5000mRange := impl/pot5000m/potrange;
		unit<spoint> pot10000mRange:= impl/pot10000m/potrange;
	}
}